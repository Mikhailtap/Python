'''При обычном вызове функции, ее состояние не сохраняется после передачи
результата. То есть, при следующей итерации она будет обрабатывать 
те же инструкции от начала до конца.
Придумали функцию-генератор. Она возвращает ОБЪЕКТ, а не значение. При 
этом она сохраняет состояние своего последнего вызова и при следующем 
вызове продолжает работу с той же точки. 
Функция-генератор такая же, как и обычная функция, но содержащая генераторную
инструкцию. Начинается с yield - определяет объект-генератор, который
возвращается генератору, вызвавшему функцию. После исполнения функции
именно состояние объекта-генератора замораживается и при следующем вызове 
функция будет идти с последнего момента. Объект может быть присвоен переменной
с помощью функции next() можно, передав ей имя этой переменной, продолжить
выполнение функции с той самой точки заморозки.
Повторный вызов с помощью next() прожолжает исполнение функции до тех пор,
пока не вызовется исключение. Его можно избежать, поместив генераторную
инструкцию внутрь бесконечного цикла.'''

def incrementer():
    i=1
    while True:
        yield i
        i+=1
inc = incrementer()
print(next(inc))
print(next(inc))
print(next(inc)) 
#кароче, понятно, да? С помощью next() от переменной от функции можно 
#использовать сколь кгодно раз наш генератор без повторного вызова, он
#будет происходить сам. Мы же просто контролируем и вызываем ОБЪЕКТ
#из заморозки, а после сразу же возвращаем его туда же. 


'''def fib_gen():
    a = b = 1
    while True:
        yield a
        a, b = b, a + b
fib = fib_gen()
for i in fib:
    if i>100:
        break
    else:
        print ('Generated: ', i)'''